#include "vtkRenderer.h"
#include "vtkRenderWindow.h"
#include "vtkRenderWindowInteractor.h"
#include "vtkPolyData.h"
#include "vtkPolyDataMapper.h"
#include "vtkPolyDataReader.h"
#include "vtkPolyDataWriter.h"
#include "vtkDataSetMapper.h"
#include "vtkPoints.h"
#include "vtkCellArray.h"
#include "vtkActor.h"
#include "vtkProperty.h"
#include "vtkCamera.h"
#include "vtkLight.h"

#include "vtkSphereSource.h"
#include "vtkPlaneSource.h"
#include "vtkGlyph3D.h"
#include "vtkDelaunay3D.h"

#include "vtkUnstructuredGrid.h"
#include "vtkUnstructuredGridReader.h"

#include "vtkTimerLog.h"
#include "vtkCommand.h"
#include "vtkInteractorStyle.h"
#include "vtkInteractorStyleUser.h"

#include "vtkBMMInterface.h"
#include "vtkFEMMesh.h"
#include "itkMesh.h"


#include <iostream>

class vtkMyCallback : public vtkCommand
{

	public:

	static vtkMyCallback *New()
	{
		return new vtkMyCallback;
	}

	virtual void Execute(vtkObject *caller, unsigned long Id, void* ptVal)
	{
		//vtkInteractorStyle *style = static_cast< vtkInteractorStyle* >(caller);
		switch( Id)
		{
			case vtkCommand::UserEvent: // <-- Never captured event
				std::cout << "***** UserEvent *****\n";
			break;
		}
	}
}; 

int main(int ac, char* av[])
{
	vtkPolyDataReader * reader = vtkPolyDataReader::New();
	if(ac < 1) reader->SetFileName("../data/planegrid.vtk");
	else reader->SetFileName(av[1]);
	reader->Update();
	
	vtkPolyData * mesh = reader->GetOutput();
	mesh->Update();

	std::cout << "[Test] Input grid #points: " << mesh->GetNumberOfPoints() << "\n";
	std::cout << "[Test] Input grid #cells: " << mesh->GetNumberOfCells() << "\n";
	
	//Contact	Points Emulation
	vtkContactCollection * contacts = vtkContactCollection::New();
	vtkPoints * points = mesh->GetPoints();
	vtkIdList * cells = vtkIdList::New();
	
	vtkPointLocator * locator = vtkPointLocator::New();
	double bounds[6];
	mesh->GetBounds(bounds);
	double point[3] = {(bounds[0]+(bounds[1]-bounds[0])/2),
                       (bounds[2]+(bounds[3]-bounds[2])/2),
                       (bounds[4]+(bounds[5]-bounds[4])/2)};
	locator->SetDataSet(mesh);
	
	vtkIdType id = locator->FindClosestPoint(point);
	
	for(vtkIdType pointId=id; pointId<id+2;pointId++)
	{
		mesh->GetPointCells(pointId,cells);
		//cells->Print(std::cout);
	
		double * point = points->GetPoint(pointId);
	
		vtkContact * contact = vtkContact::New();
		contact->SetToolId(0);
		contact->SetDeformableId(0);
		contact->SetBoxId(0);
	
		contact->SetFaceId(cells->GetId(0));
		contact->SetVertexId(pointId);
		contact->SetVertexPosition(point[0], point[1], point[2]);
		
		contacts->InsertContact(contact);

		cells->Reset();
	}


	vtkTimerLog * timer = vtkTimerLog::New();
	
	vtkBMMInterface * interface = vtkBMMInterface::New();
	interface->SetInput(mesh);
	interface->SetContacts(contacts);
	timer->StartTimer();
	interface->Update();
	timer->StopTimer();

	std::cout << "[Test] Execution Rate: " << 1/timer->GetElapsedTime() << " Hz\n";
	
	vtkPolyData * ogrid = interface->GetOutput();
	ogrid->Update();

	std::cout << "[Test] Output grid #points: " << ogrid->GetNumberOfPoints() << "\n";
	std::cout << "[Test] Output grid #cells: " << ogrid->GetNumberOfCells() << "\n";

	vtkRenderer * renderer = vtkRenderer::New();
	vtkRenderWindow * renWin = vtkRenderWindow::New();
	renWin->SetSize(500,500);
	renWin->AddRenderer(renderer);
	
	/*vtkLight * light =  vtkLight::New();
	renderer->ResetCamera();
	vtkCamera * cam = renderer->GetActiveCamera();
	cam->Elevation(90);
	cam->SetViewUp(0,0,-1);
	cam->Zoom(1.5);
	light->SetPosition(cam->GetPosition());
	light->SetFocalPoint(cam->GetFocalPoint());*/

	vtkRenderWindowInteractor * iren = vtkRenderWindowInteractor::New();
	iren->SetRenderWindow(renWin);

	vtkSphereSource *sphere = vtkSphereSource::New();
	sphere->SetRadius(0.003);
	sphere->SetThetaResolution(8); sphere->SetPhiResolution(8);
	
	vtkGlyph3D *spheres = vtkGlyph3D::New();
	spheres->SetInput(mesh);
	spheres->SetSource(sphere->GetOutput());

	vtkPolyDataMapper * mapper = vtkPolyDataMapper::New();
	mapper->SetInputConnection(spheres->GetOutputPort());
	mapper->ImmediateModeRenderingOn();	
	
	vtkActor * meshActor = vtkActor::New();
	meshActor->SetMapper(mapper);
	meshActor->GetProperty()->SetColor(1,0,0);
	//renderer->AddActor(meshActor);

	//vtkGlyph3D * spheres2 = vtkGlyph3D::New();
	//spheres2->SetInput(ogrid);
	//spheres2->SetSource(sphere->GetOutput());

	//vtkPolyDataMapper * mapper2 = vtkPolyDataMapper::New();
	//mapper2->SetInputConnection(spheres2->GetOutputPort());
	vtkDataSetMapper * mapper2 = vtkDataSetMapper::New();
	mapper2->SetInput(ogrid);
	mapper2->ImmediateModeRenderingOn();

	vtkActor * meshActor2 = vtkActor::New();
	meshActor2->SetMapper(mapper2);
	meshActor2->GetProperty()->SetColor(0,0,1);
	meshActor2->GetProperty()->SetRepresentationToWireframe();
	renderer->AddActor(meshActor2);

	
	vtkPolyData * pd3 = vtkPolyData::New();
	pd3->SetPoints(interface->GetBounds());
	pd3->Update();

	vtkGlyph3D * spheres3 = vtkGlyph3D::New();
	spheres3->SetInput(pd3);
	spheres3->SetSource(sphere->GetOutput());
	
	vtkPolyDataMapper * mapper3 = vtkPolyDataMapper::New();
	mapper3->SetInput(spheres3->GetOutput());
	mapper3->ImmediateModeRenderingOn();

	vtkActor * meshActor3 = vtkActor::New();
	meshActor3->SetMapper(mapper3);
	meshActor3->GetProperty()->SetColor(1,1,0);
	renderer->AddActor(meshActor3);
	

	vtkPolyData * pd4 = vtkPolyData::New();
	pd4->SetPoints(interface->GetContacts());
	pd4->Update();

	vtkGlyph3D * spheres4 = vtkGlyph3D::New();
	spheres4->SetInput(pd4);
	spheres4->SetSource(sphere->GetOutput());
	
	vtkPolyDataMapper * mapper4 = vtkPolyDataMapper::New();
	mapper4->SetInput(spheres4->GetOutput());
	mapper4->ScalarVisibilityOff();

	vtkActor * meshActor4 = vtkActor::New();
	meshActor4->SetMapper(mapper4);
	meshActor4->GetProperty()->SetColor(0,1,0);
	renderer->AddActor(meshActor4);

	vtkGlyph3D * spheres5 = vtkGlyph3D::New();
	spheres5->SetInput(interface->GetClippedMesh());
	spheres5->SetSource(sphere->GetOutput());
	
	vtkPolyDataMapper * mapper5 = vtkPolyDataMapper::New();
	mapper5->SetInput(spheres5->GetOutput());
	mapper5->ScalarVisibilityOff();

	vtkActor * meshActor5 = vtkActor::New();
	meshActor5->SetMapper(mapper5);
	meshActor5->GetProperty()->SetColor(1,0,0);
//	renderer->AddActor(meshActor5);

	vtkMyCallback * cb = vtkMyCallback::New();
	iren->AddObserver(vtkCommand::UserEvent, cb);
	iren->Initialize();
	
	renWin->Render();  
	
  iren->Start();

  reader->Delete();
	sphere->Delete();
	spheres->Delete();
	//spheres2->Delete();
	spheres3->Delete();
	spheres4->Delete();
	spheres5->Delete();
	meshActor->Delete();
	meshActor2->Delete();
	meshActor3->Delete();
	meshActor4->Delete();
	meshActor5->Delete();
	mapper->Delete();
	mapper2->Delete();
	mapper3->Delete();
	mapper4->Delete();
	mapper5->Delete();
	interface->Delete();
	renderer->Delete();
	renWin->Delete();
	iren->Delete();
  return 0;
}
